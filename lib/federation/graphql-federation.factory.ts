import { IResolvers } from '@graphql-tools/utils';
import { Injectable } from '@nestjs/common';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isString } from '@nestjs/common/utils/shared.utils';
import { gql } from 'apollo-server-core';
import {
  GraphQLAbstractType,
  GraphQLResolveInfo,
  GraphQLSchema,
  GraphQLTypeResolver,
  GraphQLUnionType,
} from 'graphql';
import { mergeSchemas } from 'graphql-tools';
import { isEmpty } from 'lodash';
import { GraphQLSchemaBuilder } from '../graphql-schema.builder';
import { GqlModuleOptions } from '../interfaces';
import {
  PluginsExplorerService,
  ResolversExplorerService,
  ScalarsExplorerService,
} from '../services';
import { extend } from '../utils';

@Injectable()
export class GraphQLFederationFactory {
  constructor(
    private readonly resolversExplorerService: ResolversExplorerService,
    private readonly scalarsExplorerService: ScalarsExplorerService,
    private readonly pluginsExplorerService: PluginsExplorerService,
    private readonly gqlSchemaBuilder: GraphQLSchemaBuilder,
  ) {}

  async mergeOptions(
    options: GqlModuleOptions = {},
  ): Promise<GqlModuleOptions> {
    const transformSchema = async (schema) =>
      options.transformSchema ? options.transformSchema(schema) : schema;

    options.plugins = extend(
      options.plugins || [],
      this.pluginsExplorerService.explore(),
    );

    let schema: GraphQLSchema;
    if (options.autoSchemaFile) {
      schema = await this.generateSchema(options);
    } else if (isEmpty(options.typeDefs)) {
      schema = options.schema;
    } else {
      schema = this.buildSchemaFromTypeDefs(options);
    }

    return {
      ...options,
      schema: await transformSchema(schema),
      typeDefs: undefined,
    };
  }

  private buildSchemaFromTypeDefs(options: GqlModuleOptions) {
    const { buildFederatedSchema } = loadPackage(
      '@apollo/federation',
      'ApolloFederation',
      () => require('@apollo/federation'),
    );

    return buildFederatedSchema([
      {
        typeDefs: gql`
          ${options.typeDefs}
        `,
        resolvers: this.getResolvers(options.resolvers),
      },
    ]);
  }

  private async generateSchema(
    options: GqlModuleOptions,
  ): Promise<GraphQLSchema> {
    const {
      buildFederatedSchema,
      printSchema,
    } = loadPackage('@apollo/federation', 'ApolloFederation', () =>
      require('@apollo/federation'),
    );

    const autoGeneratedSchema: GraphQLSchema = await this.gqlSchemaBuilder.buildFederatedSchema(
      options.autoSchemaFile,
      options,
      this.resolversExplorerService.getAllCtors(),
    );
    const executableSchema = buildFederatedSchema({
      typeDefs: gql(printSchema(autoGeneratedSchema)),
      resolvers: Object.assign(
        {},
        this.getUnionTypeResolvers(autoGeneratedSchema),
        this.getResolvers(options.resolvers),
      ),
    });

    const schema = options.schema
      ? mergeSchemas({
          schemas: [options.schema, executableSchema],
        })
      : executableSchema;

    return schema;
  }

  private getUnionTypeResolvers(
    autoGeneratedSchema: GraphQLSchema,
  ): IResolvers {
    const autoGeneratedTypes = Object.values(autoGeneratedSchema.getTypeMap());
    const autoGeneratedUnionTypes = autoGeneratedTypes.filter(
      (type): type is GraphQLUnionType => type instanceof GraphQLUnionType,
    );
    if (autoGeneratedUnionTypes.length === 0) {
      return {};
    }
    return autoGeneratedUnionTypes.reduce<IResolvers>(
      (unionResolvers, unionType) => {
        if (!unionType.resolveType) {
          return unionResolvers;
        }
        const __resolveType: GraphQLTypeResolver<any, any> = async (
          value: any,
          context: any,
          info: GraphQLResolveInfo,
          abstractType: GraphQLAbstractType,
        ) => {
          const result = await unionType.resolveType(
            value,
            context,
            info,
            abstractType,
          );
          if (isString(result)) {
            return result;
          }
          // for some reason this doesnt work if we return the resolved
          // type object, but does if we return just the name
          return result.name;
        };
        return { ...unionResolvers, [unionType.name]: { __resolveType } };
      },
      {},
    );
  }

  private getResolvers(optionResolvers: IResolvers | Array<IResolvers>) {
    optionResolvers = Array.isArray(optionResolvers)
      ? optionResolvers
      : [optionResolvers];
    return this.extendResolvers([
      this.resolversExplorerService.explore(),
      ...this.scalarsExplorerService.explore(),
      ...optionResolvers,
    ]);
  }

  private extendResolvers(resolvers: any[]) {
    return resolvers.reduce((prev, curr) => extend(prev, curr), {});
  }
}
